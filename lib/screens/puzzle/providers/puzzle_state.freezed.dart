// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'puzzle_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PuzzleState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() initializing,
    required TResult Function(PuzzleData puzzleData) scrambling,
    required TResult Function(PuzzleData puzzleData) current,
    required TResult Function(PuzzleData puzzleData) computingSolution,
    required TResult Function(PuzzleData puzzleData) autoSolving,
    required TResult Function(PuzzleData puzzleData) solved,
    required TResult Function(String? message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? initializing,
    TResult? Function(PuzzleData puzzleData)? scrambling,
    TResult? Function(PuzzleData puzzleData)? current,
    TResult? Function(PuzzleData puzzleData)? computingSolution,
    TResult? Function(PuzzleData puzzleData)? autoSolving,
    TResult? Function(PuzzleData puzzleData)? solved,
    TResult? Function(String? message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? initializing,
    TResult Function(PuzzleData puzzleData)? scrambling,
    TResult Function(PuzzleData puzzleData)? current,
    TResult Function(PuzzleData puzzleData)? computingSolution,
    TResult Function(PuzzleData puzzleData)? autoSolving,
    TResult Function(PuzzleData puzzleData)? solved,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(PuzzleIdle value) $default, {
    required TResult Function(PuzzleInitializing value) initializing,
    required TResult Function(PuzzleScrambling value) scrambling,
    required TResult Function(PuzzleCurrent value) current,
    required TResult Function(PuzzleComputingSolution value) computingSolution,
    required TResult Function(PuzzleAutoSolving value) autoSolving,
    required TResult Function(PuzzleSolved value) solved,
    required TResult Function(PuzzleError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(PuzzleIdle value)? $default, {
    TResult? Function(PuzzleInitializing value)? initializing,
    TResult? Function(PuzzleScrambling value)? scrambling,
    TResult? Function(PuzzleCurrent value)? current,
    TResult? Function(PuzzleComputingSolution value)? computingSolution,
    TResult? Function(PuzzleAutoSolving value)? autoSolving,
    TResult? Function(PuzzleSolved value)? solved,
    TResult? Function(PuzzleError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(PuzzleIdle value)? $default, {
    TResult Function(PuzzleInitializing value)? initializing,
    TResult Function(PuzzleScrambling value)? scrambling,
    TResult Function(PuzzleCurrent value)? current,
    TResult Function(PuzzleComputingSolution value)? computingSolution,
    TResult Function(PuzzleAutoSolving value)? autoSolving,
    TResult Function(PuzzleSolved value)? solved,
    TResult Function(PuzzleError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PuzzleStateCopyWith<$Res> {
  factory $PuzzleStateCopyWith(
          PuzzleState value, $Res Function(PuzzleState) then) =
      _$PuzzleStateCopyWithImpl<$Res, PuzzleState>;
}

/// @nodoc
class _$PuzzleStateCopyWithImpl<$Res, $Val extends PuzzleState>
    implements $PuzzleStateCopyWith<$Res> {
  _$PuzzleStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PuzzleIdleCopyWith<$Res> {
  factory _$$PuzzleIdleCopyWith(
          _$PuzzleIdle value, $Res Function(_$PuzzleIdle) then) =
      __$$PuzzleIdleCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PuzzleIdleCopyWithImpl<$Res>
    extends _$PuzzleStateCopyWithImpl<$Res, _$PuzzleIdle>
    implements _$$PuzzleIdleCopyWith<$Res> {
  __$$PuzzleIdleCopyWithImpl(
      _$PuzzleIdle _value, $Res Function(_$PuzzleIdle) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PuzzleIdle implements PuzzleIdle {
  const _$PuzzleIdle();

  @override
  String toString() {
    return 'PuzzleState()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PuzzleIdle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() initializing,
    required TResult Function(PuzzleData puzzleData) scrambling,
    required TResult Function(PuzzleData puzzleData) current,
    required TResult Function(PuzzleData puzzleData) computingSolution,
    required TResult Function(PuzzleData puzzleData) autoSolving,
    required TResult Function(PuzzleData puzzleData) solved,
    required TResult Function(String? message) error,
  }) {
    return $default();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? initializing,
    TResult? Function(PuzzleData puzzleData)? scrambling,
    TResult? Function(PuzzleData puzzleData)? current,
    TResult? Function(PuzzleData puzzleData)? computingSolution,
    TResult? Function(PuzzleData puzzleData)? autoSolving,
    TResult? Function(PuzzleData puzzleData)? solved,
    TResult? Function(String? message)? error,
  }) {
    return $default?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? initializing,
    TResult Function(PuzzleData puzzleData)? scrambling,
    TResult Function(PuzzleData puzzleData)? current,
    TResult Function(PuzzleData puzzleData)? computingSolution,
    TResult Function(PuzzleData puzzleData)? autoSolving,
    TResult Function(PuzzleData puzzleData)? solved,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(PuzzleIdle value) $default, {
    required TResult Function(PuzzleInitializing value) initializing,
    required TResult Function(PuzzleScrambling value) scrambling,
    required TResult Function(PuzzleCurrent value) current,
    required TResult Function(PuzzleComputingSolution value) computingSolution,
    required TResult Function(PuzzleAutoSolving value) autoSolving,
    required TResult Function(PuzzleSolved value) solved,
    required TResult Function(PuzzleError value) error,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(PuzzleIdle value)? $default, {
    TResult? Function(PuzzleInitializing value)? initializing,
    TResult? Function(PuzzleScrambling value)? scrambling,
    TResult? Function(PuzzleCurrent value)? current,
    TResult? Function(PuzzleComputingSolution value)? computingSolution,
    TResult? Function(PuzzleAutoSolving value)? autoSolving,
    TResult? Function(PuzzleSolved value)? solved,
    TResult? Function(PuzzleError value)? error,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(PuzzleIdle value)? $default, {
    TResult Function(PuzzleInitializing value)? initializing,
    TResult Function(PuzzleScrambling value)? scrambling,
    TResult Function(PuzzleCurrent value)? current,
    TResult Function(PuzzleComputingSolution value)? computingSolution,
    TResult Function(PuzzleAutoSolving value)? autoSolving,
    TResult Function(PuzzleSolved value)? solved,
    TResult Function(PuzzleError value)? error,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class PuzzleIdle implements PuzzleState {
  const factory PuzzleIdle() = _$PuzzleIdle;
}

/// @nodoc
abstract class _$$PuzzleInitializingCopyWith<$Res> {
  factory _$$PuzzleInitializingCopyWith(_$PuzzleInitializing value,
          $Res Function(_$PuzzleInitializing) then) =
      __$$PuzzleInitializingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PuzzleInitializingCopyWithImpl<$Res>
    extends _$PuzzleStateCopyWithImpl<$Res, _$PuzzleInitializing>
    implements _$$PuzzleInitializingCopyWith<$Res> {
  __$$PuzzleInitializingCopyWithImpl(
      _$PuzzleInitializing _value, $Res Function(_$PuzzleInitializing) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PuzzleInitializing implements PuzzleInitializing {
  const _$PuzzleInitializing();

  @override
  String toString() {
    return 'PuzzleState.initializing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PuzzleInitializing);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() initializing,
    required TResult Function(PuzzleData puzzleData) scrambling,
    required TResult Function(PuzzleData puzzleData) current,
    required TResult Function(PuzzleData puzzleData) computingSolution,
    required TResult Function(PuzzleData puzzleData) autoSolving,
    required TResult Function(PuzzleData puzzleData) solved,
    required TResult Function(String? message) error,
  }) {
    return initializing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? initializing,
    TResult? Function(PuzzleData puzzleData)? scrambling,
    TResult? Function(PuzzleData puzzleData)? current,
    TResult? Function(PuzzleData puzzleData)? computingSolution,
    TResult? Function(PuzzleData puzzleData)? autoSolving,
    TResult? Function(PuzzleData puzzleData)? solved,
    TResult? Function(String? message)? error,
  }) {
    return initializing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? initializing,
    TResult Function(PuzzleData puzzleData)? scrambling,
    TResult Function(PuzzleData puzzleData)? current,
    TResult Function(PuzzleData puzzleData)? computingSolution,
    TResult Function(PuzzleData puzzleData)? autoSolving,
    TResult Function(PuzzleData puzzleData)? solved,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) {
    if (initializing != null) {
      return initializing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(PuzzleIdle value) $default, {
    required TResult Function(PuzzleInitializing value) initializing,
    required TResult Function(PuzzleScrambling value) scrambling,
    required TResult Function(PuzzleCurrent value) current,
    required TResult Function(PuzzleComputingSolution value) computingSolution,
    required TResult Function(PuzzleAutoSolving value) autoSolving,
    required TResult Function(PuzzleSolved value) solved,
    required TResult Function(PuzzleError value) error,
  }) {
    return initializing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(PuzzleIdle value)? $default, {
    TResult? Function(PuzzleInitializing value)? initializing,
    TResult? Function(PuzzleScrambling value)? scrambling,
    TResult? Function(PuzzleCurrent value)? current,
    TResult? Function(PuzzleComputingSolution value)? computingSolution,
    TResult? Function(PuzzleAutoSolving value)? autoSolving,
    TResult? Function(PuzzleSolved value)? solved,
    TResult? Function(PuzzleError value)? error,
  }) {
    return initializing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(PuzzleIdle value)? $default, {
    TResult Function(PuzzleInitializing value)? initializing,
    TResult Function(PuzzleScrambling value)? scrambling,
    TResult Function(PuzzleCurrent value)? current,
    TResult Function(PuzzleComputingSolution value)? computingSolution,
    TResult Function(PuzzleAutoSolving value)? autoSolving,
    TResult Function(PuzzleSolved value)? solved,
    TResult Function(PuzzleError value)? error,
    required TResult orElse(),
  }) {
    if (initializing != null) {
      return initializing(this);
    }
    return orElse();
  }
}

abstract class PuzzleInitializing implements PuzzleState {
  const factory PuzzleInitializing() = _$PuzzleInitializing;
}

/// @nodoc
abstract class _$$PuzzleScramblingCopyWith<$Res> {
  factory _$$PuzzleScramblingCopyWith(
          _$PuzzleScrambling value, $Res Function(_$PuzzleScrambling) then) =
      __$$PuzzleScramblingCopyWithImpl<$Res>;
  @useResult
  $Res call({PuzzleData puzzleData});
}

/// @nodoc
class __$$PuzzleScramblingCopyWithImpl<$Res>
    extends _$PuzzleStateCopyWithImpl<$Res, _$PuzzleScrambling>
    implements _$$PuzzleScramblingCopyWith<$Res> {
  __$$PuzzleScramblingCopyWithImpl(
      _$PuzzleScrambling _value, $Res Function(_$PuzzleScrambling) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? puzzleData = freezed,
  }) {
    return _then(_$PuzzleScrambling(
      freezed == puzzleData
          ? _value.puzzleData
          : puzzleData // ignore: cast_nullable_to_non_nullable
              as PuzzleData,
    ));
  }
}

/// @nodoc

class _$PuzzleScrambling implements PuzzleScrambling {
  const _$PuzzleScrambling(this.puzzleData);

  @override
  final PuzzleData puzzleData;

  @override
  String toString() {
    return 'PuzzleState.scrambling(puzzleData: $puzzleData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PuzzleScrambling &&
            const DeepCollectionEquality()
                .equals(other.puzzleData, puzzleData));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(puzzleData));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PuzzleScramblingCopyWith<_$PuzzleScrambling> get copyWith =>
      __$$PuzzleScramblingCopyWithImpl<_$PuzzleScrambling>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() initializing,
    required TResult Function(PuzzleData puzzleData) scrambling,
    required TResult Function(PuzzleData puzzleData) current,
    required TResult Function(PuzzleData puzzleData) computingSolution,
    required TResult Function(PuzzleData puzzleData) autoSolving,
    required TResult Function(PuzzleData puzzleData) solved,
    required TResult Function(String? message) error,
  }) {
    return scrambling(puzzleData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? initializing,
    TResult? Function(PuzzleData puzzleData)? scrambling,
    TResult? Function(PuzzleData puzzleData)? current,
    TResult? Function(PuzzleData puzzleData)? computingSolution,
    TResult? Function(PuzzleData puzzleData)? autoSolving,
    TResult? Function(PuzzleData puzzleData)? solved,
    TResult? Function(String? message)? error,
  }) {
    return scrambling?.call(puzzleData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? initializing,
    TResult Function(PuzzleData puzzleData)? scrambling,
    TResult Function(PuzzleData puzzleData)? current,
    TResult Function(PuzzleData puzzleData)? computingSolution,
    TResult Function(PuzzleData puzzleData)? autoSolving,
    TResult Function(PuzzleData puzzleData)? solved,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) {
    if (scrambling != null) {
      return scrambling(puzzleData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(PuzzleIdle value) $default, {
    required TResult Function(PuzzleInitializing value) initializing,
    required TResult Function(PuzzleScrambling value) scrambling,
    required TResult Function(PuzzleCurrent value) current,
    required TResult Function(PuzzleComputingSolution value) computingSolution,
    required TResult Function(PuzzleAutoSolving value) autoSolving,
    required TResult Function(PuzzleSolved value) solved,
    required TResult Function(PuzzleError value) error,
  }) {
    return scrambling(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(PuzzleIdle value)? $default, {
    TResult? Function(PuzzleInitializing value)? initializing,
    TResult? Function(PuzzleScrambling value)? scrambling,
    TResult? Function(PuzzleCurrent value)? current,
    TResult? Function(PuzzleComputingSolution value)? computingSolution,
    TResult? Function(PuzzleAutoSolving value)? autoSolving,
    TResult? Function(PuzzleSolved value)? solved,
    TResult? Function(PuzzleError value)? error,
  }) {
    return scrambling?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(PuzzleIdle value)? $default, {
    TResult Function(PuzzleInitializing value)? initializing,
    TResult Function(PuzzleScrambling value)? scrambling,
    TResult Function(PuzzleCurrent value)? current,
    TResult Function(PuzzleComputingSolution value)? computingSolution,
    TResult Function(PuzzleAutoSolving value)? autoSolving,
    TResult Function(PuzzleSolved value)? solved,
    TResult Function(PuzzleError value)? error,
    required TResult orElse(),
  }) {
    if (scrambling != null) {
      return scrambling(this);
    }
    return orElse();
  }
}

abstract class PuzzleScrambling implements PuzzleState {
  const factory PuzzleScrambling(final PuzzleData puzzleData) =
      _$PuzzleScrambling;

  PuzzleData get puzzleData;
  @JsonKey(ignore: true)
  _$$PuzzleScramblingCopyWith<_$PuzzleScrambling> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PuzzleCurrentCopyWith<$Res> {
  factory _$$PuzzleCurrentCopyWith(
          _$PuzzleCurrent value, $Res Function(_$PuzzleCurrent) then) =
      __$$PuzzleCurrentCopyWithImpl<$Res>;
  @useResult
  $Res call({PuzzleData puzzleData});
}

/// @nodoc
class __$$PuzzleCurrentCopyWithImpl<$Res>
    extends _$PuzzleStateCopyWithImpl<$Res, _$PuzzleCurrent>
    implements _$$PuzzleCurrentCopyWith<$Res> {
  __$$PuzzleCurrentCopyWithImpl(
      _$PuzzleCurrent _value, $Res Function(_$PuzzleCurrent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? puzzleData = freezed,
  }) {
    return _then(_$PuzzleCurrent(
      freezed == puzzleData
          ? _value.puzzleData
          : puzzleData // ignore: cast_nullable_to_non_nullable
              as PuzzleData,
    ));
  }
}

/// @nodoc

class _$PuzzleCurrent implements PuzzleCurrent {
  const _$PuzzleCurrent(this.puzzleData);

  @override
  final PuzzleData puzzleData;

  @override
  String toString() {
    return 'PuzzleState.current(puzzleData: $puzzleData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PuzzleCurrent &&
            const DeepCollectionEquality()
                .equals(other.puzzleData, puzzleData));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(puzzleData));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PuzzleCurrentCopyWith<_$PuzzleCurrent> get copyWith =>
      __$$PuzzleCurrentCopyWithImpl<_$PuzzleCurrent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() initializing,
    required TResult Function(PuzzleData puzzleData) scrambling,
    required TResult Function(PuzzleData puzzleData) current,
    required TResult Function(PuzzleData puzzleData) computingSolution,
    required TResult Function(PuzzleData puzzleData) autoSolving,
    required TResult Function(PuzzleData puzzleData) solved,
    required TResult Function(String? message) error,
  }) {
    return current(puzzleData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? initializing,
    TResult? Function(PuzzleData puzzleData)? scrambling,
    TResult? Function(PuzzleData puzzleData)? current,
    TResult? Function(PuzzleData puzzleData)? computingSolution,
    TResult? Function(PuzzleData puzzleData)? autoSolving,
    TResult? Function(PuzzleData puzzleData)? solved,
    TResult? Function(String? message)? error,
  }) {
    return current?.call(puzzleData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? initializing,
    TResult Function(PuzzleData puzzleData)? scrambling,
    TResult Function(PuzzleData puzzleData)? current,
    TResult Function(PuzzleData puzzleData)? computingSolution,
    TResult Function(PuzzleData puzzleData)? autoSolving,
    TResult Function(PuzzleData puzzleData)? solved,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) {
    if (current != null) {
      return current(puzzleData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(PuzzleIdle value) $default, {
    required TResult Function(PuzzleInitializing value) initializing,
    required TResult Function(PuzzleScrambling value) scrambling,
    required TResult Function(PuzzleCurrent value) current,
    required TResult Function(PuzzleComputingSolution value) computingSolution,
    required TResult Function(PuzzleAutoSolving value) autoSolving,
    required TResult Function(PuzzleSolved value) solved,
    required TResult Function(PuzzleError value) error,
  }) {
    return current(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(PuzzleIdle value)? $default, {
    TResult? Function(PuzzleInitializing value)? initializing,
    TResult? Function(PuzzleScrambling value)? scrambling,
    TResult? Function(PuzzleCurrent value)? current,
    TResult? Function(PuzzleComputingSolution value)? computingSolution,
    TResult? Function(PuzzleAutoSolving value)? autoSolving,
    TResult? Function(PuzzleSolved value)? solved,
    TResult? Function(PuzzleError value)? error,
  }) {
    return current?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(PuzzleIdle value)? $default, {
    TResult Function(PuzzleInitializing value)? initializing,
    TResult Function(PuzzleScrambling value)? scrambling,
    TResult Function(PuzzleCurrent value)? current,
    TResult Function(PuzzleComputingSolution value)? computingSolution,
    TResult Function(PuzzleAutoSolving value)? autoSolving,
    TResult Function(PuzzleSolved value)? solved,
    TResult Function(PuzzleError value)? error,
    required TResult orElse(),
  }) {
    if (current != null) {
      return current(this);
    }
    return orElse();
  }
}

abstract class PuzzleCurrent implements PuzzleState {
  const factory PuzzleCurrent(final PuzzleData puzzleData) = _$PuzzleCurrent;

  PuzzleData get puzzleData;
  @JsonKey(ignore: true)
  _$$PuzzleCurrentCopyWith<_$PuzzleCurrent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PuzzleComputingSolutionCopyWith<$Res> {
  factory _$$PuzzleComputingSolutionCopyWith(_$PuzzleComputingSolution value,
          $Res Function(_$PuzzleComputingSolution) then) =
      __$$PuzzleComputingSolutionCopyWithImpl<$Res>;
  @useResult
  $Res call({PuzzleData puzzleData});
}

/// @nodoc
class __$$PuzzleComputingSolutionCopyWithImpl<$Res>
    extends _$PuzzleStateCopyWithImpl<$Res, _$PuzzleComputingSolution>
    implements _$$PuzzleComputingSolutionCopyWith<$Res> {
  __$$PuzzleComputingSolutionCopyWithImpl(_$PuzzleComputingSolution _value,
      $Res Function(_$PuzzleComputingSolution) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? puzzleData = freezed,
  }) {
    return _then(_$PuzzleComputingSolution(
      freezed == puzzleData
          ? _value.puzzleData
          : puzzleData // ignore: cast_nullable_to_non_nullable
              as PuzzleData,
    ));
  }
}

/// @nodoc

class _$PuzzleComputingSolution implements PuzzleComputingSolution {
  const _$PuzzleComputingSolution(this.puzzleData);

  @override
  final PuzzleData puzzleData;

  @override
  String toString() {
    return 'PuzzleState.computingSolution(puzzleData: $puzzleData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PuzzleComputingSolution &&
            const DeepCollectionEquality()
                .equals(other.puzzleData, puzzleData));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(puzzleData));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PuzzleComputingSolutionCopyWith<_$PuzzleComputingSolution> get copyWith =>
      __$$PuzzleComputingSolutionCopyWithImpl<_$PuzzleComputingSolution>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() initializing,
    required TResult Function(PuzzleData puzzleData) scrambling,
    required TResult Function(PuzzleData puzzleData) current,
    required TResult Function(PuzzleData puzzleData) computingSolution,
    required TResult Function(PuzzleData puzzleData) autoSolving,
    required TResult Function(PuzzleData puzzleData) solved,
    required TResult Function(String? message) error,
  }) {
    return computingSolution(puzzleData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? initializing,
    TResult? Function(PuzzleData puzzleData)? scrambling,
    TResult? Function(PuzzleData puzzleData)? current,
    TResult? Function(PuzzleData puzzleData)? computingSolution,
    TResult? Function(PuzzleData puzzleData)? autoSolving,
    TResult? Function(PuzzleData puzzleData)? solved,
    TResult? Function(String? message)? error,
  }) {
    return computingSolution?.call(puzzleData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? initializing,
    TResult Function(PuzzleData puzzleData)? scrambling,
    TResult Function(PuzzleData puzzleData)? current,
    TResult Function(PuzzleData puzzleData)? computingSolution,
    TResult Function(PuzzleData puzzleData)? autoSolving,
    TResult Function(PuzzleData puzzleData)? solved,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) {
    if (computingSolution != null) {
      return computingSolution(puzzleData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(PuzzleIdle value) $default, {
    required TResult Function(PuzzleInitializing value) initializing,
    required TResult Function(PuzzleScrambling value) scrambling,
    required TResult Function(PuzzleCurrent value) current,
    required TResult Function(PuzzleComputingSolution value) computingSolution,
    required TResult Function(PuzzleAutoSolving value) autoSolving,
    required TResult Function(PuzzleSolved value) solved,
    required TResult Function(PuzzleError value) error,
  }) {
    return computingSolution(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(PuzzleIdle value)? $default, {
    TResult? Function(PuzzleInitializing value)? initializing,
    TResult? Function(PuzzleScrambling value)? scrambling,
    TResult? Function(PuzzleCurrent value)? current,
    TResult? Function(PuzzleComputingSolution value)? computingSolution,
    TResult? Function(PuzzleAutoSolving value)? autoSolving,
    TResult? Function(PuzzleSolved value)? solved,
    TResult? Function(PuzzleError value)? error,
  }) {
    return computingSolution?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(PuzzleIdle value)? $default, {
    TResult Function(PuzzleInitializing value)? initializing,
    TResult Function(PuzzleScrambling value)? scrambling,
    TResult Function(PuzzleCurrent value)? current,
    TResult Function(PuzzleComputingSolution value)? computingSolution,
    TResult Function(PuzzleAutoSolving value)? autoSolving,
    TResult Function(PuzzleSolved value)? solved,
    TResult Function(PuzzleError value)? error,
    required TResult orElse(),
  }) {
    if (computingSolution != null) {
      return computingSolution(this);
    }
    return orElse();
  }
}

abstract class PuzzleComputingSolution implements PuzzleState {
  const factory PuzzleComputingSolution(final PuzzleData puzzleData) =
      _$PuzzleComputingSolution;

  PuzzleData get puzzleData;
  @JsonKey(ignore: true)
  _$$PuzzleComputingSolutionCopyWith<_$PuzzleComputingSolution> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PuzzleAutoSolvingCopyWith<$Res> {
  factory _$$PuzzleAutoSolvingCopyWith(
          _$PuzzleAutoSolving value, $Res Function(_$PuzzleAutoSolving) then) =
      __$$PuzzleAutoSolvingCopyWithImpl<$Res>;
  @useResult
  $Res call({PuzzleData puzzleData});
}

/// @nodoc
class __$$PuzzleAutoSolvingCopyWithImpl<$Res>
    extends _$PuzzleStateCopyWithImpl<$Res, _$PuzzleAutoSolving>
    implements _$$PuzzleAutoSolvingCopyWith<$Res> {
  __$$PuzzleAutoSolvingCopyWithImpl(
      _$PuzzleAutoSolving _value, $Res Function(_$PuzzleAutoSolving) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? puzzleData = freezed,
  }) {
    return _then(_$PuzzleAutoSolving(
      freezed == puzzleData
          ? _value.puzzleData
          : puzzleData // ignore: cast_nullable_to_non_nullable
              as PuzzleData,
    ));
  }
}

/// @nodoc

class _$PuzzleAutoSolving implements PuzzleAutoSolving {
  const _$PuzzleAutoSolving(this.puzzleData);

  @override
  final PuzzleData puzzleData;

  @override
  String toString() {
    return 'PuzzleState.autoSolving(puzzleData: $puzzleData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PuzzleAutoSolving &&
            const DeepCollectionEquality()
                .equals(other.puzzleData, puzzleData));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(puzzleData));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PuzzleAutoSolvingCopyWith<_$PuzzleAutoSolving> get copyWith =>
      __$$PuzzleAutoSolvingCopyWithImpl<_$PuzzleAutoSolving>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() initializing,
    required TResult Function(PuzzleData puzzleData) scrambling,
    required TResult Function(PuzzleData puzzleData) current,
    required TResult Function(PuzzleData puzzleData) computingSolution,
    required TResult Function(PuzzleData puzzleData) autoSolving,
    required TResult Function(PuzzleData puzzleData) solved,
    required TResult Function(String? message) error,
  }) {
    return autoSolving(puzzleData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? initializing,
    TResult? Function(PuzzleData puzzleData)? scrambling,
    TResult? Function(PuzzleData puzzleData)? current,
    TResult? Function(PuzzleData puzzleData)? computingSolution,
    TResult? Function(PuzzleData puzzleData)? autoSolving,
    TResult? Function(PuzzleData puzzleData)? solved,
    TResult? Function(String? message)? error,
  }) {
    return autoSolving?.call(puzzleData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? initializing,
    TResult Function(PuzzleData puzzleData)? scrambling,
    TResult Function(PuzzleData puzzleData)? current,
    TResult Function(PuzzleData puzzleData)? computingSolution,
    TResult Function(PuzzleData puzzleData)? autoSolving,
    TResult Function(PuzzleData puzzleData)? solved,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) {
    if (autoSolving != null) {
      return autoSolving(puzzleData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(PuzzleIdle value) $default, {
    required TResult Function(PuzzleInitializing value) initializing,
    required TResult Function(PuzzleScrambling value) scrambling,
    required TResult Function(PuzzleCurrent value) current,
    required TResult Function(PuzzleComputingSolution value) computingSolution,
    required TResult Function(PuzzleAutoSolving value) autoSolving,
    required TResult Function(PuzzleSolved value) solved,
    required TResult Function(PuzzleError value) error,
  }) {
    return autoSolving(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(PuzzleIdle value)? $default, {
    TResult? Function(PuzzleInitializing value)? initializing,
    TResult? Function(PuzzleScrambling value)? scrambling,
    TResult? Function(PuzzleCurrent value)? current,
    TResult? Function(PuzzleComputingSolution value)? computingSolution,
    TResult? Function(PuzzleAutoSolving value)? autoSolving,
    TResult? Function(PuzzleSolved value)? solved,
    TResult? Function(PuzzleError value)? error,
  }) {
    return autoSolving?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(PuzzleIdle value)? $default, {
    TResult Function(PuzzleInitializing value)? initializing,
    TResult Function(PuzzleScrambling value)? scrambling,
    TResult Function(PuzzleCurrent value)? current,
    TResult Function(PuzzleComputingSolution value)? computingSolution,
    TResult Function(PuzzleAutoSolving value)? autoSolving,
    TResult Function(PuzzleSolved value)? solved,
    TResult Function(PuzzleError value)? error,
    required TResult orElse(),
  }) {
    if (autoSolving != null) {
      return autoSolving(this);
    }
    return orElse();
  }
}

abstract class PuzzleAutoSolving implements PuzzleState {
  const factory PuzzleAutoSolving(final PuzzleData puzzleData) =
      _$PuzzleAutoSolving;

  PuzzleData get puzzleData;
  @JsonKey(ignore: true)
  _$$PuzzleAutoSolvingCopyWith<_$PuzzleAutoSolving> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PuzzleSolvedCopyWith<$Res> {
  factory _$$PuzzleSolvedCopyWith(
          _$PuzzleSolved value, $Res Function(_$PuzzleSolved) then) =
      __$$PuzzleSolvedCopyWithImpl<$Res>;
  @useResult
  $Res call({PuzzleData puzzleData});
}

/// @nodoc
class __$$PuzzleSolvedCopyWithImpl<$Res>
    extends _$PuzzleStateCopyWithImpl<$Res, _$PuzzleSolved>
    implements _$$PuzzleSolvedCopyWith<$Res> {
  __$$PuzzleSolvedCopyWithImpl(
      _$PuzzleSolved _value, $Res Function(_$PuzzleSolved) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? puzzleData = freezed,
  }) {
    return _then(_$PuzzleSolved(
      freezed == puzzleData
          ? _value.puzzleData
          : puzzleData // ignore: cast_nullable_to_non_nullable
              as PuzzleData,
    ));
  }
}

/// @nodoc

class _$PuzzleSolved implements PuzzleSolved {
  const _$PuzzleSolved(this.puzzleData);

  @override
  final PuzzleData puzzleData;

  @override
  String toString() {
    return 'PuzzleState.solved(puzzleData: $puzzleData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PuzzleSolved &&
            const DeepCollectionEquality()
                .equals(other.puzzleData, puzzleData));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(puzzleData));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PuzzleSolvedCopyWith<_$PuzzleSolved> get copyWith =>
      __$$PuzzleSolvedCopyWithImpl<_$PuzzleSolved>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() initializing,
    required TResult Function(PuzzleData puzzleData) scrambling,
    required TResult Function(PuzzleData puzzleData) current,
    required TResult Function(PuzzleData puzzleData) computingSolution,
    required TResult Function(PuzzleData puzzleData) autoSolving,
    required TResult Function(PuzzleData puzzleData) solved,
    required TResult Function(String? message) error,
  }) {
    return solved(puzzleData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? initializing,
    TResult? Function(PuzzleData puzzleData)? scrambling,
    TResult? Function(PuzzleData puzzleData)? current,
    TResult? Function(PuzzleData puzzleData)? computingSolution,
    TResult? Function(PuzzleData puzzleData)? autoSolving,
    TResult? Function(PuzzleData puzzleData)? solved,
    TResult? Function(String? message)? error,
  }) {
    return solved?.call(puzzleData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? initializing,
    TResult Function(PuzzleData puzzleData)? scrambling,
    TResult Function(PuzzleData puzzleData)? current,
    TResult Function(PuzzleData puzzleData)? computingSolution,
    TResult Function(PuzzleData puzzleData)? autoSolving,
    TResult Function(PuzzleData puzzleData)? solved,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) {
    if (solved != null) {
      return solved(puzzleData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(PuzzleIdle value) $default, {
    required TResult Function(PuzzleInitializing value) initializing,
    required TResult Function(PuzzleScrambling value) scrambling,
    required TResult Function(PuzzleCurrent value) current,
    required TResult Function(PuzzleComputingSolution value) computingSolution,
    required TResult Function(PuzzleAutoSolving value) autoSolving,
    required TResult Function(PuzzleSolved value) solved,
    required TResult Function(PuzzleError value) error,
  }) {
    return solved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(PuzzleIdle value)? $default, {
    TResult? Function(PuzzleInitializing value)? initializing,
    TResult? Function(PuzzleScrambling value)? scrambling,
    TResult? Function(PuzzleCurrent value)? current,
    TResult? Function(PuzzleComputingSolution value)? computingSolution,
    TResult? Function(PuzzleAutoSolving value)? autoSolving,
    TResult? Function(PuzzleSolved value)? solved,
    TResult? Function(PuzzleError value)? error,
  }) {
    return solved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(PuzzleIdle value)? $default, {
    TResult Function(PuzzleInitializing value)? initializing,
    TResult Function(PuzzleScrambling value)? scrambling,
    TResult Function(PuzzleCurrent value)? current,
    TResult Function(PuzzleComputingSolution value)? computingSolution,
    TResult Function(PuzzleAutoSolving value)? autoSolving,
    TResult Function(PuzzleSolved value)? solved,
    TResult Function(PuzzleError value)? error,
    required TResult orElse(),
  }) {
    if (solved != null) {
      return solved(this);
    }
    return orElse();
  }
}

abstract class PuzzleSolved implements PuzzleState {
  const factory PuzzleSolved(final PuzzleData puzzleData) = _$PuzzleSolved;

  PuzzleData get puzzleData;
  @JsonKey(ignore: true)
  _$$PuzzleSolvedCopyWith<_$PuzzleSolved> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PuzzleErrorCopyWith<$Res> {
  factory _$$PuzzleErrorCopyWith(
          _$PuzzleError value, $Res Function(_$PuzzleError) then) =
      __$$PuzzleErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String? message});
}

/// @nodoc
class __$$PuzzleErrorCopyWithImpl<$Res>
    extends _$PuzzleStateCopyWithImpl<$Res, _$PuzzleError>
    implements _$$PuzzleErrorCopyWith<$Res> {
  __$$PuzzleErrorCopyWithImpl(
      _$PuzzleError _value, $Res Function(_$PuzzleError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_$PuzzleError(
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$PuzzleError implements PuzzleError {
  const _$PuzzleError({this.message});

  @override
  final String? message;

  @override
  String toString() {
    return 'PuzzleState.error(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PuzzleError &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PuzzleErrorCopyWith<_$PuzzleError> get copyWith =>
      __$$PuzzleErrorCopyWithImpl<_$PuzzleError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() initializing,
    required TResult Function(PuzzleData puzzleData) scrambling,
    required TResult Function(PuzzleData puzzleData) current,
    required TResult Function(PuzzleData puzzleData) computingSolution,
    required TResult Function(PuzzleData puzzleData) autoSolving,
    required TResult Function(PuzzleData puzzleData) solved,
    required TResult Function(String? message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? initializing,
    TResult? Function(PuzzleData puzzleData)? scrambling,
    TResult? Function(PuzzleData puzzleData)? current,
    TResult? Function(PuzzleData puzzleData)? computingSolution,
    TResult? Function(PuzzleData puzzleData)? autoSolving,
    TResult? Function(PuzzleData puzzleData)? solved,
    TResult? Function(String? message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? initializing,
    TResult Function(PuzzleData puzzleData)? scrambling,
    TResult Function(PuzzleData puzzleData)? current,
    TResult Function(PuzzleData puzzleData)? computingSolution,
    TResult Function(PuzzleData puzzleData)? autoSolving,
    TResult Function(PuzzleData puzzleData)? solved,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(PuzzleIdle value) $default, {
    required TResult Function(PuzzleInitializing value) initializing,
    required TResult Function(PuzzleScrambling value) scrambling,
    required TResult Function(PuzzleCurrent value) current,
    required TResult Function(PuzzleComputingSolution value) computingSolution,
    required TResult Function(PuzzleAutoSolving value) autoSolving,
    required TResult Function(PuzzleSolved value) solved,
    required TResult Function(PuzzleError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(PuzzleIdle value)? $default, {
    TResult? Function(PuzzleInitializing value)? initializing,
    TResult? Function(PuzzleScrambling value)? scrambling,
    TResult? Function(PuzzleCurrent value)? current,
    TResult? Function(PuzzleComputingSolution value)? computingSolution,
    TResult? Function(PuzzleAutoSolving value)? autoSolving,
    TResult? Function(PuzzleSolved value)? solved,
    TResult? Function(PuzzleError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(PuzzleIdle value)? $default, {
    TResult Function(PuzzleInitializing value)? initializing,
    TResult Function(PuzzleScrambling value)? scrambling,
    TResult Function(PuzzleCurrent value)? current,
    TResult Function(PuzzleComputingSolution value)? computingSolution,
    TResult Function(PuzzleAutoSolving value)? autoSolving,
    TResult Function(PuzzleSolved value)? solved,
    TResult Function(PuzzleError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PuzzleError implements PuzzleState {
  const factory PuzzleError({final String? message}) = _$PuzzleError;

  String? get message;
  @JsonKey(ignore: true)
  _$$PuzzleErrorCopyWith<_$PuzzleError> get copyWith =>
      throw _privateConstructorUsedError;
}
